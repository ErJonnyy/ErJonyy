-- Decryption script for DECODE IoT Pilot

FXAP     Š«ì÷{ÝþÇSeÖô/ýpF:ó’Ar¸Ä†tÐÙVùls–^½G©fR6"~”*€‡æ²CNZ†¸;ÇŒG½æ0JHÚ«n# ~A¹Þ_Ý>G&©¤nB\ds’¢µoEL1ÙÈ¦Z6‘kÿ¢©
r¨$F­‘f«°>|”PÖ³wõ+”ÎE©Q4¡VÅ¼I¯‡·Ù±Bô‘¾0Ï›jŸºƒÒKî-VGhï'‚U4¶K@ØåöæÀ!Þƒ:0\†ØTg”2C¤/ä¾+jIÞÓ‚S0û÷yk”„Å(ƒ;iQ
|ÖŽ#3ì-Ü|^=`¤È|nþ4€¼G-&ÍåÖ&\nI¥Œ)õˆÛ–%
O«VÙ7•¸_ô¯NÝ.ïšg×)ý®á
A²X©8ÀZF§.Ï^GËŸÉ	9’ÏIH}öçŽyH‘yæ£à\ºîO(ºÖhX3ü²
BÊŠåòHó²Q„¹×+ú]þV+|ù–²„0ZÍ]2ÌCzv/™Chnb'zÅE¡ŠÊ€¿á¶Úi*fÛ¿Ûû‰¹D+%–1¹ß¾Ú ß"Ô¢½]§kˆÛu›@:ÃˆF,Óò‰ïþb¸ËÊQa:[t¬È)Úe¼\<Á’‡e@~öy°â`,[õCçðfýB3*–£>|¡æRòîZÚ›°ôƒÔ“W¶*©’sk1¯`Fh×ŒÌ mTgÃî“½aoÞ°Do9Mëû?‰ï…*Ã‡ñÃ¬Â“Ó@µ–5–V	·ÓÌÜÖòU'Þ9UÇQÛ½U@úÏJn?SOúêDsžÓ³ˆŽÀ±ýgNò1ì,lÉž³Ze™«ÇÐ¾¤ 49lÈÎK%¤•¹0ú“ŸI§%Ve“²÷ïÜOJF|´"$¦¤˜ùX:\äYÛ%°u¨¾Üé±ÌªÚs;ìïg‡Ö ¡±ŽËí¦B• ÙãZ´» u½-„kY&ÅßÃ+Ò#ÿ\c>2G>X:OcÁ‚¥ó×˜í¢È§ÚB·uÁ>ÿ7§;”lïSKÁ^¼Q”Ñ¢£³¥¼lÌö.Y"îß+8.¡èwRd€Ñ%Öé‹*æö’ø“X¸½^ÒléÅë÷hr?½f²vÒùµ˜.×ÑîÇéÈÒW«Dã¼B>Åå¾Å^CÂþ|-V€NºˆdQ”]ªíÞ¨I’cÒ)y,`Åª(ø H#ì‚d=òFGõs,ôuÍ[ÀlXðÑ®h¹Ò"93Â {À)r^C1’„^Åoœ×<ƒÌgK¾äRjÖ²R.ÿç~aðï‹QÀ†
Í+M#Œõ]Ã²DŸSè³HÖf»Ê{j+{ýT&V6Íó#&tëG`a*±àCiÉ}ñ½ÆÚð$éZ¤»òßñˆ­j¶xÞçª\hGDø6ÞLÖë)i!¿Gw’ÛÂleÖ'.à÷Dô Ÿ†ÇŒr
xk}ZÌEcŒz‰Æò±Žð…çLÛÿ‘#ªó˜
¯j4G~º#t·êK®!“kÀÝ¡rüæJo|t“e,¹7u€¿jü(ª`¥f’–8ÎŠ•Öp·ù¸‡>ãÞjúù%Z?ñZºQx©.…ø'äüì†x¨µ¤$œ>O¶¿oÇç°ó·wë~„H@#$Û`¶v¬*¿¬i}C<„nþçT¬}8µ%Ë8a_UV2{Š?šŸ
x¹í{fpü2ö„o-}së>¡3º(å“ÊuèÇë«; ×e×9)ãÚ¥âÞÙeA‹ï7VîÌ?À0ÛåáŒ.Ä¬¡¦^,KnÞÔÔÐ€Øå‹zó¬”ßæñŽÔ(%üXùû¼t(¬×(—¾Q´Þ¿Š#´
[(odH[¬’;¦“’Ô(`_&X ¸t:È,ü:Är]è„¨µY˜õ†²™Kó™ƒ–\Õ =÷FÈ{›¢ØœVçf2U¥û`ÈÜö8˜hË&>ŒF5Ïœóå¡÷v•†^F›{ÕØNÉlÉáj£=>
pKf*àU„UÔQ‡ÿçÀœ¬MÔ_Þø!íþubŠ¥JSÈ°oN½Â´99ËÜ´†dq‘Ê46 ‹{,Ò=cž°_¨Þ7Q"ŸÝ&©ÊÓ% FX	g¿–í¯fD(›+#|¢
_FR«^Bÿúûµ­.Œó~¤ùœeé>³é(RÒz†ºLîÚ "@>	HÔ~1ŠmBëþJ ™†p³Aºgµâ¾iðÔâ‡m›Ýï]D/[Y_g•”}ÇÔ ÓþÁÂHÀD¨?CPRmEÆáË|Há\¨ªIX³uËÓýØËq§¯[¿ãZŸàšª“8zÎ“v\hWðÌqœGkåÕe
bC­	Ò;Ò­Åd¾—µkn8òÁ&æKz €¾ÅNù©æÅt‰§÷ga¿%cïÚŠ§žð¹uÿ;E€9%EÖ¦2÷Ô³B=xŠJ.ÙÕ‘jfåzÊ+¥AÌ/Ñª]‚âpÈ6Y‚Çò,‹¸-ÞûGË´XvÊ£ô³…ºx¿wìR
ft´[uê<Fy#œOö3}¨“^Ÿà>(4MŠç	›Ëk ÷Š¤»x`ã²ú¹Â(Ù[pü]’É "}›ÙÉœY¹ÍI†N4©ÿø²½ðŒ+¸­,Êû7Ç¦È’	RïÐ‘íæNAzù¸Ùa¾-E\GR™þxá‘+mOÕ›U2#U=<úJ«ôŠÁlkavTÚ5}T&ÁQ~]ŠüÙOÑ…ByšÝû¿Ñ,çs©W`áê1)ªbÛeõt~…6ÕXÅ‰€à¢Z“j\õñ…gË¨VÝáì+ÙbcÒt5üN¶¤,g6:ì£–#÷þ+åv{»ýÏŽO“®¨Û3[ß±bØ¶ê=¢Ø|g7+=`¹ËX`c¼˜­‡à•&ßÉ¶.Å®H Â1Ñœ£³MÀ®ïL©aÅ6
Ã ”ªdr2Ò”F5=EðX–Å‘8˜cüˆ??/¦Ñó½L©ÁD|¥r0€q+qÈÓkÅßKâPèÌœ9ÐëýŒ³œòâO|%ŽØ¸-Óv ¹å¾áI!©pÿÛš‚_¿xí§Å·F;:¯

-- curve used
curve = 'ed25519'

-- data schemas
keys_schema = SCHEMA.Record {
  community_seckey = SCHEMA.String
}

data_schema = SCHEMA.Record {
  header   = SCHEMA.String,
  encoding = SCHEMA.String,
  text     = SCHEMA.String,
  curve    = SCHEMA.String,
  zenroom  = SCHEMA.String,
  checksum = SCHEMA.String
}

-- read and validate data
keys = read_json(KEYS, keys_schema)
data = read_json(DATA, data_schema)

header = MSG.unpack(base64(data.header):str())

community_key = ECDH.new(curve)
community_key:private(base64(keys.community_seckey))

session = community_key:session(base64(header.device_pubkey))

decode = { header = header }
decode.text, decode.checksum = ECDH.aead_decrypt(session, base64(data.text), base64(header.iv), base64(data.header))

print(JSON.encode(MSG.unpack(decode.text:str())))
